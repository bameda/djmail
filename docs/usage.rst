.. _usage:

==========
How to use
==========

djmail works as middleware, and the simplest way to use it, is to not hink, just send
emails the way you did before.


Email delivery backends
-----------------------

djmail provides two backends:

* **default**: sends emails on the same process/thread or in another thread.
* **celery**: sends emails asynchronously with celery tasks.

Default
^^^^^^^

This backend works in two modes: **standard** or **async**.

The **standard** mode, works similar to any backend of django, with the exception of status tracking
and failure scheduling.

The **async** mode, works the same way like the standard mode but sends the email in a new thread.

Celery
^^^^^^

The celery backend uses celery async tasks to send emails and is always asyncronous. It has the
same behavior as the default backend.

Example configuration with celery backend:

.. code-block:: python

    EMAIL_BACKEND="djmail.backends.celery.EmailBackend"
    DJMAIL_REAL_BACKEND="django.core.mail.backends.console.EmailBackend"


Email retry methods
-------------------

djmail implements two methods for delivering failed email messages:

* With operating system crond service.
* With celery periodic tasks.

If your choice is crond, you need to execute this management command every N min/sec:

.. code-block:: console

    python manage.py djmail_retry_send_messages


But if your choice is celery periodic tasks, this is a possible example of a configuration:

.. code-block:: python

    from datetime import timedelta

    CELERYBEAT_SCHEDULE = {
        'djmail-retry-send-every-120-seconds': {
            'task': 'tasks.retry_send_messages',
            'schedule': timedelta(seconds=120),
        },
    }

Also, you can customize the maximum number of retries with the following settings parameters:

.. code-block:: python

    DJMAIL_MAX_RETRY_NUMBER = 5


Render emails with templates
----------------------------

djmail implements two classes for building emails from templates.

* **djmail.template_mail.TemplateMail**: low lever interface.
* **djmail.template_mail.MagicMailBuilder**: very powerful and magical interface.


TemplateMail
^^^^^^^^^^^^

The ``TemplateMail`` is a low level implementation for building emails from templates.

Given below is a simple example for using it:

.. code-block:: python

    # Define a subclass of TemplateMail
    class SomeTemplateEmail(template_mail.TemplateMail):
        name = "some_email"

    # Create an instance
    email = SomeTemplateEmail()

    # Buld and send a message with specified context
    email.send("to@example.com", {"template": "context"})

Also you can obtain a native django email instance from TemplateMail instance:

.. code-block:: python

    # Create an instance
    template_email = SomeTemplateEmail()

    # Or obtain a native django email object
    email = template_email.make_email_object("to@example.com",
                                             {"template": "context"})
    email.send()


An object of TemplateMail or its subclass, by default will search for these templates:

* **emails/some_email-body-html.html**
* **emails/some_email-body-text.html**
* **emails/some_email-subject.html**

.. note::

    Text version of email body is omitted if template does not exist.

You can change the search pattern with some settings parameters that you
can see in :ref:`Settings <settings>` section.


MagicMailBuilder
^^^^^^^^^^^^^^^^

This is a more powerful method for building messages from templates. It delegates an email
building to a TemplateMail but exposes a more easy and dynamic api.

This example represents the same behavior as the previous example:

.. code-block:: python

    # Create MagicMailBuilder instance
    mails = template_mail.MagicMailBuilder()

    # Create a native email object.
    # NOTE: The method name represents an email name.
    email = mails.some_email("to@example.com", {"template": "context"})
    email.send()


Additionally, instead of receiver email address you can pass a django model
instance that represents a user:

.. code-block:: python

    class MyUser(models.Model):
        email = models.CharField(max_length=200)
        lang = models.CharField(max_length=200, default="es")
        # [...]

    user = MyUser.objects.get(pk=1)
    email = mails.some_email(user, {"template": "context"})


If you user class has an email/lang field with other names, you can customize it
with some parameters to a constructor of MagicMailBuilder:

I18n
^^^^

Both of the previous apis implement i18n for rendering an email body and subject. For using a
specific language you must pass ``lang`` attribute on a context parameter.

Example:

.. code-block:: python

    email = mails.some_email("to@example.com",
                             {"template": "context", "lang": "es"})

Priority
^^^^^^^^

The dynamic methods generated by **MagicMailBuilder**, accepts **priority** as optional
keyword argument (by default with 50 as priority value)-

.. note::

   Email objects with low priority are not sent immediately, the sending
   is delayed until the next scheduled delivery process (with cron or celery).


.. code-block:: python

    email = mails.some_email("to@example.com", {"template": "context"},
                             priority=100)
